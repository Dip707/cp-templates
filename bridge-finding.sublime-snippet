<snippet>
	<content><![CDATA[
// uses vector adj of the form pair<int, int> : {next node, edge id}
vector<int> low, t_in, vtd, is_bridge;
int timer = 0;

void bridge_dfs(int v, int p = -1) {

	vtd[v] = 1;
	t_in[v] = low[v] = timer++;

	for(auto e : adj[v]) {

		int u = e.fe, edge_id = e.se;

		if(u == p) {

			continue;
		}

		if(vtd[u]) {

			low[v] = min(low[v], t_in[u]);

		} else {

			bridge_dfs(u, v);
			low[v] = min(low[v], low[u]);

			if(low[u] > t_in[v]) {

				is_bridge[edge_id] = 1;
			}
		}
	}
}

void find_bridges() {

	low.assign(n_nodes, -1);
	t_in.assign(n_nodes, -1);
	vtd.assign(n_nodes, 0);
	is_bridge.assign(n_edges, 0);

	fr(v, 0, n_nodes) {

		if(!vtd[v]) {

			bridge_dfs(v);
		}
	}
}
]]></content>
	<tabTrigger>bridge-finding</tabTrigger>
	<scope>source.c++</scope>
	<description>Finding bridges in a graph</description>
</snippet>
