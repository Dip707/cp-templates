<snippet>
	<content><![CDATA[
// include DSU struct
// include graph struct
// uses vector adj of the form pair<int, int> : {next node, edge id}
vector<int> low, t_in, vtd, is_bridge;
int timer = 0;

void bridge_dfs(vector<vector<pii>>& adj, int v, int p = -1) {

	vtd[v] = 1;
	t_in[v] = low[v] = timer++;

	for(auto e : adj[v]) {

		int u = e.fe, edge_id = e.se;

		if(u == p) {

			continue;
		}

		if(vtd[u]) {

			low[v] = min(low[v], t_in[u]);

		} else {

			bridge_dfs(adj, u, v);
			low[v] = min(low[v], low[u]);

			if(low[u] > t_in[v]) {

				is_bridge[edge_id] = 1;
			}
		}
	}
}

void find_bridges(vector<vector<pii>>& adj, vector<pii>& edges) {

	int N = (int)adj.size();
	int E = (int)edges.size();

	low.assign(N, -1);
	t_in.assign(N, -1);
	vtd.assign(N, 0);
	is_bridge.assign(E, 0);

	fr(v, 0, N) {

		if(!vtd[v]) {

			bridge_dfs(adj, v);
		}
	}
}

graph get_bridge_tree(graph& g) {

	find_bridges(g.g, g.edges);
	DSU og(g.n_nodes);

	fr(i, 0, (int)g.edges.size()) {

		if(is_bridge[i]) continue;
		og.dsu(g.edges[i].fe, g.edges[i].se);
	}

	graph bridge_tree(g.n_nodes);

	fr(i, 0, (int)g.edges.size()) {

		if(!is_bridge[i]) continue;
		bridge_tree.add_edge(og.component_of[g.edges[i].fe], og.component_of[g.edges[i].se], i);
	}

	return bridge_tree;
}
]]></content>
	<tabTrigger>bridge-finding</tabTrigger>
	<scope>source.c++</scope>
	<description>Finding bridges in a graph</description>
</snippet>
